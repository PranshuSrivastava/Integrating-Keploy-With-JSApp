"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GENERIC_EXPORT = exports.HTTP_EXPORT = exports.V1_BETA1 = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
const client_1 = __importStar(require("./client"));
const util_1 = require("./util");
const package_json_1 = require("../package.json");
const grpc = __importStar(require("@grpc/grpc-js"));
const protoLoader = __importStar(require("@grpc/proto-loader"));
const path_1 = __importDefault(require("path"));
const assert = require("assert");
const context_1 = require("./context");
const PORT = 6789;
const PROTO_PATH = "../proto/services.proto";
const packageDef = protoLoader.loadSync(path_1.default.resolve(__dirname, PROTO_PATH));
const grpcObj = grpc.loadPackageDefinition(packageDef);
exports.V1_BETA1 = "api.keploy.io/v1beta1", exports.HTTP_EXPORT = "Http", exports.GENERIC_EXPORT = "Generic";
class Keploy {
    constructor(app = {}, server = {}) {
        this.grpcClient = new grpcObj.services.RegressionService(`0.0.0.0:${PORT}`, grpc.credentials.createInsecure());
        this.appConfig = this.validateAppConfig(app);
        this.serverConfig = this.validateServerConfig(server);
        this.responses = {};
        this.dependencies = {};
        this.mocks = {};
        this.client = new client_1.default(this.serverConfig.url);
    }
    validateServerConfig({ url = process.env.KEPLOY_SERVER_URL || "http://localhost:6789/api", licenseKey = process.env.KEPLOY_LICENSE_KEY || "", }) {
        return { url, licenseKey };
    }
    validateAppConfig({ name = process.env.KEPLOY_APP_NAME || package_json_1.name, host = process.env.KEPLOY_APP_HOST || "localhost", port = process.env.KEPLOY_APP_PORT || 8080, delay = process.env.KEPLOY_APP_DELAY || 5, timeout = process.env.KEPLOY_APP_TIMEOUT || 60, filter = process.env.KEPLOY_APP_FILTER || {}, 
    // testCasePath and mockPath can be defined in the .env file. If not defined then a folder named
    // keploy-tests will be created which will contain mock folder.
    testCasePath = path_1.default.resolve(process.env.KEPLOY_TEST_CASE_PATH || "./keploy-tests"), mockPath = path_1.default.resolve(process.env.KEPLOY_MOCK_PATH || "./keploy-tests/mock"), }) {
        const errorFactory = (key) => new Error(`Invalid App config key: ${key}`);
        port = Number(port);
        if (Number.isNaN(port)) {
            throw errorFactory("port");
        }
        delay = Number(delay);
        if (Number.isNaN(delay)) {
            throw errorFactory("delay");
        }
        timeout = Number(timeout);
        if (Number.isNaN(timeout)) {
            throw errorFactory("timeout");
        }
        if (typeof filter === "string") {
            try {
                filter = JSON.parse(filter);
            }
            catch (_a) {
                throw errorFactory("filter");
            }
        }
        return { name, host, port, delay, timeout, filter, testCasePath, mockPath };
    }
    runTests() {
        return __awaiter(this, void 0, void 0, function* () {
            if (process.env.KEPLOY_MODE == "test") {
                console.log("test starting in " + this.appConfig.delay + "s");
                setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.test();
                }), this.appConfig.delay * 1000);
                // await this.test();
            }
            return this;
        });
    }
    getDependencies(id) {
        return this.dependencies[id];
    }
    getMocks(id) {
        return this.mocks[id];
    }
    getResp(id) {
        return this.responses[id];
    }
    putResp(id, resp) {
        this.responses[id] = resp;
    }
    capture(req) {
        return this.put(req);
    }
    fetch(testcases, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            const limit = 25;
            const app = this.appConfig.name;
            let end = false;
            yield this.grpcClient.getTcs({
                app: app,
                offset: offset.toString(),
                limit: limit.toString(),
                TestCasePath: this.appConfig.testCasePath,
                MockPath: this.appConfig.mockPath,
            }, (err, response) => {
                if (err !== null) {
                    console.error("failed to fetch test cases from keploy. error: ", err);
                }
                if (response == null ||
                    response.tcs == undefined ||
                    response.tcs.length == 0) {
                    // Base case of the recursive function.
                    // If the response is null then all the testcases cases will go to the afterfetch function.
                    end = true;
                    this.afterFetch(testcases);
                    return;
                }
                testcases.push(...response.tcs);
                if (response.eof == true) {
                    // Base case of the recursive function.
                    // If the eof is true then all the testcases cases will go to the afterfetch function.
                    end = true;
                    this.afterFetch(testcases);
                    return testcases;
                }
                // Recursive call to the function fetch.
                this.fetch(testcases, offset + 25);
            });
            return testcases;
        });
    }
    test() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fetch([], 0);
        });
    }
    // returns promise to capture the code coverage of recorded testc cases
    assertTests() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                (0, context_1.createExecutionContext)({ resolve: resolve });
                yield this.test();
            }));
        });
    }
    // afterFetch fuction contains Start, Test and End grpc calls to the function.
    // The nesting is done in the grpc calls because they return their responses in the callback function.
    afterFetch(testCases) {
        return __awaiter(this, void 0, void 0, function* () {
            const totalTests = testCases.length;
            this.grpcClient.Start({
                app: this.appConfig.name,
                total: totalTests.toString(),
                MockPath: this.appConfig.mockPath,
                TestCasePath: this.appConfig.testCasePath,
            }, (err, resp) => __awaiter(this, void 0, void 0, function* () {
                if (err !== null) {
                    console.error("failed to call start method of keploy. error: ", err);
                }
                const testId = resp === null || resp === void 0 ? void 0 : resp.id;
                console.log("starting test execution. { id: ", testId, " }, { total tests: ", totalTests, " }");
                let pass = true;
                for (const [i, testCase] of testCases.entries()) {
                    console.log("testing ", i + 1, " of ", totalTests, " { testcase id: ", testCase.id, " }");
                    const resp = yield this.simulate(testCase).catch((err) => console.log(err));
                    this.grpcClient.Test({
                        AppID: this.appConfig.name,
                        ID: testCase.id,
                        RunID: testId,
                        Resp: {
                            Body: resp === null || resp === void 0 ? void 0 : resp.body,
                            StatusCode: resp === null || resp === void 0 ? void 0 : resp.status_code,
                            Header: resp === null || resp === void 0 ? void 0 : resp.header,
                        },
                    }, (err, response) => {
                        var _a, _b, _c, _d;
                        if (err !== null) {
                            console.error("failed to call test method of keploy. error: ", err);
                        }
                        if (((_a = response === null || response === void 0 ? void 0 : response.pass) === null || _a === void 0 ? void 0 : _a.pass) === false) {
                            pass = false;
                        }
                        console.log("result { testcase id: ", testCase.id, " }, { passed: ", (_b = response === null || response === void 0 ? void 0 : response.pass) === null || _b === void 0 ? void 0 : _b.pass, " }");
                        if (i === testCases.length - 1) {
                            this.end(testId, pass);
                            console.log("test run completed { run id: ", testId, " }, passed overall: ", pass);
                            // fetches resolve function of the Promise which was returned to unit test for code-coverage
                            const resolve = (_d = (_c = (0, context_1.getExecutionContext)()) === null || _c === void 0 ? void 0 : _c.context) === null || _d === void 0 ? void 0 : _d.resolve;
                            if (resolve !== undefined) {
                                // asserts for testrun result
                                assert.equal(pass, true);
                                resolve(1);
                            }
                        }
                    });
                }
            }));
        });
    }
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestUrl = `regression/testcase/${id}`;
            const request = new client_1.Request();
            request.setHttpHeader("key", this.serverConfig.licenseKey);
            return this.client.makeHttpRequest(request.get(requestUrl));
        });
    }
    end(id, status) {
        this.grpcClient.End({ id: id, status: status.toString() }, (err, response) => {
            if (err !== null) {
                console.error("failed to call end method of keploy. error: ", err);
            }
        });
        // return resp.id;
    }
    simulate(tc) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (tc.id == undefined) {
                return;
            }
            this.dependencies[tc.id] = tc.Deps;
            this.mocks[tc.id] = tc.Mocks;
            const client = new client_1.default(`http://${this.appConfig.host}:${this.appConfig.port}`);
            //@ts-ignore
            const requestUrl = `${(_a = tc.HttpReq) === null || _a === void 0 ? void 0 : _a.URL.substr(1)}`;
            yield client.makeHttpRequestRaw(new client_1.Request()
                .setHttpHeader("KEPLOY_TEST_ID", tc.id)
                //@ts-ignore
                .setHttpHeaders((0, util_1.toHttpHeaders)((_b = tc.HttpReq) === null || _b === void 0 ? void 0 : _b.Header))
                //@ts-ignore
                .create((_c = tc.HttpReq) === null || _c === void 0 ? void 0 : _c.Method, requestUrl, (_d = tc.HttpReq) === null || _d === void 0 ? void 0 : _d.Body));
            const resp = this.getResp(tc.id);
            delete this.dependencies[tc.id];
            delete this.mocks[tc.id];
            delete this.responses[tc.id];
            return resp;
        });
    }
    put(tcs) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.appConfig.filter.urlRegex &&
                ((_a = tcs === null || tcs === void 0 ? void 0 : tcs.URI) === null || _a === void 0 ? void 0 : _a.match(this.appConfig.filter.urlRegex))) {
                return;
            }
            this.grpcClient.PostTC(tcs, (err, response) => {
                if (err != null) {
                    console.error("failed to post testcase to keploy server. error: ", err);
                }
                if (response === undefined ||
                    response.tcsId === undefined ||
                    response.tcsId.id === "") {
                    return;
                }
                this.denoise(response.tcsId.id, tcs);
            });
        });
    }
    denoise(id, tcs) {
        return __awaiter(this, void 0, void 0, function* () {
            if (tcs.URI === undefined) {
                return;
            }
            const resp = yield this.simulate({
                id: id,
                URI: tcs.URI,
                HttpReq: tcs.HttpReq,
                Deps: tcs.Dependency,
                Mocks: tcs.Mocks,
            }).catch((err) => console.log(err));
            this.grpcClient.DeNoise({
                AppID: this.appConfig.name,
                ID: id,
                Resp: {
                    Body: resp === null || resp === void 0 ? void 0 : resp.body,
                    Header: resp === null || resp === void 0 ? void 0 : resp.header,
                    StatusCode: resp === null || resp === void 0 ? void 0 : resp.status_code,
                },
                TestCasePath: this.appConfig.testCasePath,
                MockPath: this.appConfig.mockPath,
            }, (err, response) => {
                if (err != undefined) {
                    console.error("failed to call denoise method of keploy. error: ", err);
                }
                return response;
            });
        });
    }
}
exports.default = Keploy;
